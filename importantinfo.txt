// Optimized alerts loading with better bin data fetching
function loadAlertsData() {
    const q = query(
        collection(db, 'alerts'),
        orderBy('ts', 'desc'),
        limit(20)
    );

    const unsubscribe = onSnapshot(q, async (snapshot) => {
        const alerts = [];
        snapshot.forEach(docSnap => {
            const alert = { id: docSnap.id, ...docSnap.data() };
            alerts.push(alert);
        });

        // More efficient bin data fetching
        const binData = new Map();
        const uniqueBinIds = [...new Set(alerts.map(alert => alert.binId))];
        
        if (uniqueBinIds.length > 0) {
            try {
                const binsQuery = query(
                    collection(db, 'bins'),
                    where('__name__', 'in', uniqueBinIds)
                );
                const binsSnapshot = await getDocs(binsQuery);
                binsSnapshot.forEach(doc => {
                    binData.set(doc.id, doc.data());
                });
            } catch (error) {
                console.error('Error loading bin data:', error);
            }
        }

        renderAlertsTable(alerts, binData);
    });

    subscriptions.push(unsubscribe);
}


// Simplified loadBinsData - remove conflicting updates
function loadBinsData() {
    const q = query(collection(db, 'bins'));

    const unsubscribe = onSnapshot(q, (snapshot) => {
        let total = 0, active = 0, maintenanceRequired = 0, outOfService = 0;
        const bins = [];

        snapshot.forEach(docSnap => {
            const bin = { id: docSnap.id, ...docSnap.data() };
            bins.push(bin);
            total++;

            if (bin.active) {
							 active++;

                const maintenanceInterval = 30 * 24 * 60 * 60 * 1000;
                const lastMaintenance = bin.updatedAt?.toDate() || bin.createdAt?.toDate();
                if (lastMaintenance && Date.now() - lastMaintenance.getTime() > maintenanceInterval) {
                    maintenanceRequired++;
                }
            } else {
                outOfService++;
            }
        });

        // Only update these specific metrics
        updateElement('[data-status="total-bins"]', total);
				updateElement('[data-status="active-bins"]', active);
        updateElement('[data-status="maintenance-required"]', maintenanceRequired);
        updateElement('[data-status="out-of-service"]', outOfService);

        window.binsData = bins;

        if (renderedSections.has('maintenance')) {
            renderMaintenanceTable(bins);
        }
    });

    subscriptions.push(unsubscribe);
}


//-----------------------------------------------------------------------
  // Consolidated real-time status tracking
function setupRealTimeStatusUpdates() {
    // Track full bins via alerts
    const fullAlertsQuery = query(
        collection(db, 'alerts'),
        where('kind', '==', 'full'),
        where('ack', '==', false)
    );
    
    const fullAlertsUnsubscribe = onSnapshot(fullAlertsQuery, (snapshot) => {
        const fullBinsCount = snapshot.size;
        updateElement('bins-full', `${fullBinsCount} bins`);
        console.log(`Real-time full bins update: ${fullBinsCount}`);
    });

    // Track active bins
    const activeBinsQuery = query(
        collection(db, 'bins'),
        where('active', '==', true)
    );
    
    const activeBinsUnsubscribe = onSnapshot(activeBinsQuery, (snapshot) => {
        const activeBinsCount = snapshot.size;
        updateElement('active-bins', `${activeBinsCount} bins`);
        console.log(`Real-time active bins update: ${activeBinsCount}`);
    });

    // Track total alerts
    const allAlertsQuery = query(
        collection(db, 'alerts'),
        where('ack', '==', false)
    );
    
    const allAlertsUnsubscribe = onSnapshot(allAlertsQuery, (snapshot) => {
        const totalAlerts = snapshot.size;
        updateElement('recent-alerts', `${totalAlerts} alerts`);
        console.log(`Real-time alerts update: ${totalAlerts}`);
    });

    subscriptions.push(fullAlertsUnsubscribe, activeBinsUnsubscribe, allAlertsUnsubscribe);
}

My concern is why for ex. scenario when there's already 3 warnings and the 3rd warning going to full but when its already full the result is 3 warnings and 1 full where its suppose to 2 warning and 1 full since the 3rd warning is updated to full.  Why is that how to fix it?